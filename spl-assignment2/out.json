package memory;

public class SharedMatrix {

    // volatile ensures visibility when the array reference is updated
    private volatile SharedVector[] vectors; 

    public SharedMatrix() {
        this.vectors = new SharedVector[0];
    }

    public SharedMatrix(double[][] matrix) {
        this.loadRowMajor(matrix);
    }

    public void loadRowMajor(double[][] matrix) {
        if (matrix == null) {
            throw new IllegalArgumentException("Matrix cannot be null");
        }
        if (matrix.length == 0) {
            this.vectors = new SharedVector[0];
            return;
        }
        
        int vec_len = matrix[0].length;
        SharedVector[] new_vectors = new SharedVector[matrix.length];
        
        for (int i = 0; i < matrix.length; i++) {
            if (matrix[i].length != vec_len) {
                throw new IllegalArgumentException("Inconsistent vector lengths in matrix");
            }
            new_vectors[i] = new SharedVector(matrix[i], VectorOrientation.ROW_MAJOR);
        }
        // Atomic switch of the array reference
        this.vectors = new_vectors;
    }

    public void loadColumnMajor(double[][] matrix) {
        if (matrix == null) {
            throw new IllegalArgumentException("Matrix cannot be null");
        }
        if (matrix.length == 0) {
            this.vectors = new SharedVector[0];
            return;
        }

        int rows = matrix.length;
        int cols = matrix[0].length;
        SharedVector[] new_vectors = new SharedVector[cols];

        for (int j = 0; j < cols; j++) {
            double[] column_vector = new double[rows];
            for (int i = 0; i < rows; i++) {
                // Check consistency while transposing
                if (matrix[i].length != cols) {
                    throw new IllegalArgumentException("Inconsistent vector lengths in matrix");
                }
                column_vector[i] = matrix[i][j];
            }
            new_vectors[j] = new SharedVector(column_vector, VectorOrientation.COLUMN_MAJOR);
        }
        // Atomic switch
        this.vectors = new_vectors;
    }

    public double[][] readRowMajor() {
        // CRITICAL FIX: Capture the reference to local variable 'snapshot' first.
        // This ensures we lock and read the exact same array objects, 
        // even if another thread calls load() and changes 'this.vectors' concurrently.
        SharedVector[] snapshot = this.vectors;

        if (snapshot.length == 0) {
            return new double[0][0];
        }

        acquireAllVectorReadLocks(snapshot);
        try {
            int rows = snapshot.length;
            int cols = snapshot[0].length();
            VectorOrientation orientation = snapshot[0].getOrientation();

            // Depending on orientation, dimensions flip in the output 2D array
            if (orientation == VectorOrientation.ROW_MAJOR) {
                double[][] result = new double[rows][cols];
                for (int i = 0; i < rows; i++) {
                    for (int j = 0; j < cols; j++) {
                        result[i][j] = snapshot[i].get(j);
                    }
                }
                return result;
            } else { 
                // COLUMN_MAJOR: The stored vectors are columns. 
                // We need to output Row-Major 2D array, so we essentially transpose.
                // 'rows' here is actually number of columns (vectors), 'cols' is number of rows.
                double[][] result = new double[cols][rows];
                for (int i = 0; i < rows; i++) { // i is column index
                    for (int j = 0; j < cols; j++) { // j is row index
                        result[j][i] = snapshot[i].get(j);
                    }
                }
                return result;
            }
        } finally {
            releaseAllVectorReadLocks(snapshot);
        }
    }

    public SharedVector get(int index) {
        // Array access is atomic; if index is out of bounds, Java throws the exception automatically.
        // We use the local reference to ensure we return a vector that belongs to the current matrix state.
        SharedVector[] snapshot = this.vectors;
        return snapshot[index];
    }

    public int length() {
        // OPTIMIZATION: No need to lock vectors to check array length.
        return this.vectors.length;
    }

    public VectorOrientation getOrientation() {
        // OPTIMIZATION: Only lock the first vector if it exists.
        SharedVector[] snapshot = this.vectors;
        if (snapshot.length == 0) {
            // Default or throw? Assignment implies matrices have dimensions.
            // Returning ROW_MAJOR as safe default for empty.
            return VectorOrientation.ROW_MAJOR; 
        }
        return snapshot[0].getOrientation();
    }

    private void acquireAllVectorReadLocks(SharedVector[] vecs) {
        for (SharedVector vec : vecs) {
            vec.readLock();
        }
    }

    private void releaseAllVectorReadLocks(SharedVector[] vecs) {
        for (SharedVector vec : vecs) {
            vec.readUnlock();
        }
    }
    
    // Unused helper methods removed or kept empty if required by skeleton strictness.
    // If skeleton requires them, keep them but ensure they are used correctly.
    // Since 'vecMatMul' is in SharedVector, we likely don't need write locks on the whole matrix often.
}